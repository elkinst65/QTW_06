---
title: "MSDS 7333 Case Study 06"
author: "Matthew Baldree, Ben Brock, Tom Elkins, Austin Kelly"
date: "June 17, 2017"
output:
  html_notebook: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Assignment: 
1. Conduct a more thorough data analysis into these two MAC addresses, including determining locations by using data corresponding to both: 
    + chosenAP = "00:0f:a3:39:e1:c0"
    + rejectedAP = "00:0f:a3:39:dd:cd"
* *Which of these two MAC addresses should be used and which should not be used for Real Time Location System (RTLS)?*
* *Which MAC address yields the best prediction of location?including determining locations by using data corresponding to both MAC addresses*
* *Does using data for both MAC addresses simultaneously yield more, or less accurate prediction of location?*

***

2. Implement alternative k-nearest precition method using weights on received signal strength.
* *For what range of values of weights are you able to obtain better prediction values than for the unweighted approach?*
* *Use calcError() to compare approaches*

## Introduction
(insert text here)

***

## The Approach (Explained)

### Part 1

Before we begin, we will need to set the parameters for printing and formatting
```{r}
options(digits = 2)
options(error = recover, warn = 2)
```
Before continuing, we will need to address another file which houses the predefined functions. This helps to save notebook real estate and prevents confusion:
```{r}
source("MSDS7333-baldree-case6-fx.r", print.eval = TRUE)
```

Read offline data
```{r}
offline = readData()
```

Conduct a more thorough data analysis into these two MAC addresses, including determining locations by using data corresponding to both:
    
    * chosenAP = "00:0f:a3:39:e1:c0"
    * rejectedAP = "00:0f:a3:39:dd:cd"
    
Since we have the two MAC addresses in question, we will declare these addresses as variables to simplify later code. 

```{r}
chosenAP = "00:0f:a3:39:e1:c0"
rejectedAP = "00:0f:a3:39:dd:cd"
remainingAP = unique(offline[!offline$mac %in% c(chosenAP, rejectedAP),]$mac)
```

* *Which of these two MAC addresses should be used and which should not be used for Real Time Location System (RTLS)?*

#### Here we will create a Signal Collection Map
For this exercise, we will plot both the count and locations of the signals recorded for the access points. Even though it would be ideal to plot the access points(APs) directly on the map, we do not know their X and Y coordinates. 

```{r}
plotSignalMaps(c(chosenAP, rejectedAP))
```

At first glance, we can see that the maps are quite similar. Unfortunately, the information gained from a visual comparison of these two diagrams does not give us a significant insight into which MAC address should be kept and which should be rejected. The next step to reach our goal will be to look at the individual Signal Strength Distributions

***

#### Signal Strength Distributions
Plotting the individual signal strength distributions for each AP angle will help add perspective to the information we are working with. For the sake of consistency, we will use the same stationary coordinates listen in the course book (2, 12) (Add reference here.)

```{r}
df = subset(offline, posX ==2 & posY == 12 & !(mac %in% remainingAP), c(signal, angle, mac))
plotBoxplotSignalStrength(df)
```

From the literature, we know the higher the decibel-milliwatts means a stronger signal strength.
<font color="red">**(consider revising this sentence. Seems incomplete.)**</font> A stronger signal strength indicates a closer position to the AP since signal strengths decrease exponentially with distance. Comparing the signal strength distributions in this chart, we see "e1:c0" has a stronger signal strength at this location than "dd:cd."

What if we compared the two addresses from the opposite end of the building? 
```{r}
# Let's focus on the fixed point (33,3)
df = subset(offline, posX == 33 & posY == 3 & !(mac %in% remainingAP), c(signal, angle, mac))
plotBoxplotSignalStrength(df)
```
Through the use of another perspective, the MAC address with the weaker signal at (2,12) still has a relatively weak signal when viewed from an AP at the other side of the building. The evidence against the address with the lower signal strength is mounting.

***

#### Time to investigate Signal Density
To properly investigate the difference between these two addresses, the signal strength densities for each address should be plotted for each angle. This will help display the defining characteristics for each address. 

```{r}

```



```{r}
df = subset(offline, posX == 24 & posY == 4 & !(mac %in% remainingAP), c(signal, angle, mac))
plotDensitySignalStrength(df)
```
<font color = "red"> <b> &uarr; having issues with this diplaying properly... &uarr;</b> </font>

#### Average Signal Strength Distributions
To examine the distribution for all locations and angles of the two APs in question, we will generate the summary statistics. The summary statistics for all possible combinations of locations and orientations for each AP through the use of a new factor. 

```{r}
offline$posXY = paste(offline$posX, offline$posY, sep="-")

# create data frames for each combination
byLocAngleAP = with(offline, by(offline, list(posXY, angle, mac), function(x) x))
```

Now, we calculate the summary statistics:
```{r}
signalSummary = lapply(byLocAngleAP, function(oneLoc) {
  ans = oneLoc[1, ]
  ans$medSignal = median(oneLoc$signal)
  ans$avgSignal = mean(oneLoc$signal)
  ans$num = length(oneLoc$signal)
  ans$sdSignal = sd(oneLoc$signal)
  ans$iqrSignal = IQR(oneLoc$signal)
  ans
})
offlineSummary = do.call("rbind", signalSummary)
```

The Standard Deviation of the average signal strength per targeted AP

```{r}
df = subset(offlineSummary, mac %in% c(chosenAP, rejectedAP), c(sdSignal, avgSignal, mac))
plotStdDevSignalStrength(df)
```


#### Let's dive into the K-Nearest Neighbors:
<font color = "red"><b>Discuss KNN here</b></font>

```{r}
macs = unique(offlineSummary$mac)
online = readData("online.final.trace.txt", subMacs = macs)
online$posXY = paste(online$posX, online$posY, sep = "-")
length(unique(online$posXY))
tabonlineXYA = table(online$posXY, online$angle)
#output shows measurements were taken at all angles throughout the floor
tabonlineXYA
```

Organize the data where each AP is in a column. 

```{r}
onlineSummary = castOnline(online)
#confirm rejected AP is included
dim(onlineSummary)
names(onlineSummary)
```


<font color = "red">(Continued from baldree-case6.r)</font>

> for k-NN, we will include training data with angles close to point in question since angle matters.
> if we want one angle, then include angles that match the rounded orientation of new observation.
> if we want two angles, then pick two multiples of 45 degrees that flank the new observation's orientation.
> if we want three angles, then pick the closest 45 degree increment and on either side of it.
> what if we didn't want to collapse the signal strengths across the m angles, and
> instead return a set of mx166 signals for each access point?

```{r}
source("MSDS7333-baldree-case6-fx.r", print.eval = TRUE)
```


```{r}
#Iterate through 1 to 3 neighbors with 1 to 3 angles for each scenario to determine best combination
#for cross validation
for (ap in c("None", rejectedAP, chosenAP)){
  if (ap == "None"){
    test = onlineSummary
    train = offlineSummary
    newSignals = test[ , 6:12]
  } else {
    test = onlineSummary[, !(names(onlineSummary) %in% ap)]
    train = subset(offlineSummary, mac != ap)
    newSignals = test[,6:11]
  }
  
  estXY = predXY(newSignals = newSignals,
                 newAngles = test[, 4],
                 train, 
                 numAngles = 3, k = 3)
  actXY = test[ , c("posX", "posY")]
  err = calcError(estXY, actXY)
  
  print(paste(ap, err))
}
```

<font color = "green" size = "5px"><b>This is where we will perform cross validation and plot for desired AP for a range of k's </b></font>

Perform cross validation and plot for desired AP for a range of k's for each fold. We want to find k-NN estimates from 1...k and aggregate errors over the v folds. 

Choose a v-fold of 11
```{r}
v = 11
```


```{r}

# number of locations
permuteLocs = sample(unique(offlineSummary$posXY))

```

```{r}
# matrix locations into folds
permuteLocs = matrix(permuteLocs, ncol = v, nrow = floor(length(permuteLocs)/v))
```
<font color = "Red"><b>&uarr; come back to this one &uarr;</b></font>

```{r}
# summarize and format offline
keepVars = c("posXY", "posX", "posY", "orientation", "angle")
onlineCVSummary = reshapeSS(offline, keepVars = keepVars, sampleAngle = TRUE)
```


```{r}
# number of k's
K = 10
# errors array
err = rep(0, K)

# loop through folds
for (j in 1:v) {
  testFold = subset(onlineCVSummary, posXY %in% permuteLocs[ , j])
  trainFold = subset(offlineSummary, posXY %in% permuteLocs[ , -j])
  actFold = testFold[ , c("posX", "posY")]

  # loop through neighbors
  for (k in 1:K) {
    estFold = predXY(newSignals = testFold[ , 6:12],
                     newAngles = testFold[ , 4],
                     trainFold, numAngles = 3, k = k)
    err[k] = err[k] + calcError(estFold, actFold)
  }
}
# plot k to sum of squared errors
plotSSErrors(err, K)
```

```{r}
# experiment with a few k's based on above analysis to determine k
# that results in lowest sum squared error on test data.
estXY = predXY(newSignals = onlineSummary[ , 6:12],
               newAngles = onlineSummary[ , 4],
               offlineSummary, numAngles = 3, k = 5)
actXY = onlineSummary[ , c("posX", "posY")]
calcError(estXY, actXY)
```

*** 
#Part 2: Alternatvie k-nearest neighbors
```{r}
# create weights for neighbors based on signal strength and multiple times X and Y and sum neighbors
# to get X and Y.
estXY = predXY(newSignals = onlineSummary[ , 6:12],
               newAngles = onlineSummary[ , 4],
               offlineSummary, numAngles = 3, k = 5, weighted=TRUE)
actXY = onlineSummary[ , c("posX", "posY")]
calcError(estXY, actXY)
```

***